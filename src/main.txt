#include <Arduino.h>
#include "display/display.hpp"
#include "buttons/buttons.hpp"
#include "bitmaps.h"

// OTA
#include <WiFi.h>
#include <ESPmDNS.h>
#include <NetworkUdp.h>
#include <ArduinoOTA.h>

#define IR_SEND_PIN 7
#define SEND_PWM_BY_TIMER  // Use hardware PWM timer

#include <IRremote.hpp>

Display display(128, 64, 2, 3, 0x3C);
ButtonGroup top(A7, 2, 3.3);

const char* ssid = "coco-wifi";
const char* password = "ekde2006";
uint32_t last_ota_time = 0;

#include <AsyncTCP.h>
#include <ESPAsyncWebServer.h>
#include <WebSerial.h>

AsyncWebServer server(80);

void setup() {
  IrSender.begin(IR_SEND_PIN);

  Serial.begin(115200);
  analogReadResolution(12); // sure
  display.init();
  delay(1000);
  display.clear();
  display.draw_bmp(BOOT);
  Serial.println("Booting");

  WiFi.mode(WIFI_STA);
  WiFi.begin(ssid, password);

  while (WiFi.waitForConnectResult() != WL_CONNECTED) {
    delay(5000);
    ESP.restart();
  }

  /*ArduinoOTA.setHostname("espremote");

  ArduinoOTA
    .onStart([]() {
      String type;
      if (ArduinoOTA.getCommand() == U_FLASH) {
        type = "sketch";
      } else {  // U_SPIFFS
        type = "filesystem";
      }

      // NOTE: if updating SPIFFS this would be the place to unmount SPIFFS using SPIFFS.end()
    })
    .onEnd([]() {
      Serial.println("\nEnd");
    })
    .onProgress([](unsigned int progress, unsigned int total) {
      if (millis() - last_ota_time > 500) {
        Serial.printf("Progress: %u%%\n", (progress / (total / 100)));
        last_ota_time = millis();
      }
    })
    .onError([](ota_error_t error) {
      Serial.printf("Error[%u]: ", error);
      if (error == OTA_AUTH_ERROR) {
        Serial.println("Auth Failed");
      } else if (error == OTA_BEGIN_ERROR) {
        Serial.println("Begin Failed");
      } else if (error == OTA_CONNECT_ERROR) {
        Serial.println("Connect Failed");
      } else if (error == OTA_RECEIVE_ERROR) {
        Serial.println("Receive Failed");
      } else if (error == OTA_END_ERROR) {
        Serial.println("End Failed");
      }
    });*/

  //ArduinoOTA.begin();

  //WebSerial.begin(&server);
  //server.begin();

  Serial.println("Ready");
  Serial.print("IP address: ");
  Serial.println(WiFi.localIP());
}

// we need a separate OTA mode so we don't block the OTA loop...
// ok maybe its fine? but we should still have one so we can show IP on screen and stuff

void loop() {
  //ArduinoOTA.handle();
  top.update();
  WebSerial.printf("Button: %d (%d)", top.get_press(), analogRead(A7));

  if (top.get_press() == 0) {
    IrSender.sendSony(0x1, 0x15, 2);
    WebSerial.println("Sent!");
  }

  delay(200);
}

// ESP32 Vibration Motor Control
// Pin 17 controls motor via S8050 transistor

/*#include <Arduino.h>

void setMotorPower(int a);
void runTestPattern();
void pulseMotor(int a, int b, int c);
void rampMotor(int a, int b, int c);

// ESP32-S2 Vibration Motor Control
// Pin 17 controls motor via S8050 transistor

const int motorPin = 17;        // GPIO pin connected to transistor base
const int pwmFrequency = 50;    // 50 Hz - good for smooth haptic feel
const int pwmResolution = 8;    // 8-bit resolution (0-255)

void setup() {
  Serial.begin(115200);
  
  // Configure pin as output
  pinMode(motorPin, OUTPUT);
  
  // For ESP32-S2, use analogWrite with frequency settings
  analogWriteFrequency(motorPin, pwmFrequency);
  analogWriteResolution(motorPin, pwmResolution);
  
  Serial.println("ESP32-S2 Motor control ready!");
  Serial.println("Commands:");
  Serial.println("  0-100: Set motor power percentage");
  Serial.println("  'off': Turn motor off");
  Serial.println("  'test': Run test pattern");
}

void loop() {
  // Check for serial commands
  setMotorPower(20);
}

// Set motor power as percentage (0-100)
void setMotorPower(int percent) {
  if (percent < 0) percent = 0;
  if (percent > 100) percent = 100;
  
  // Convert percentage to PWM value (0-255)
  int pwmValue = map(percent, 0, 100, 0, 255);
  
  analogWrite(motorPin, pwmValue);
}*/

/*Display display(128, 64, 2, 3, 0x3C);
ButtonGroup top(A7, 2, 3.3);

void setup() {
  Serial.begin(115200);
  analogReadResolution(12); // sure
  display.init();
  delay(1000);
  display.clear();
  display.draw_bmp(BOOT);
}

void loop() {
  /*if (top.is_pressed(0)) {
    display.clear();
    display.draw_bmp(HOMEASSISTANT_LG);
  }
  delay(10);
  top.update();*/
  /*top.update();
  delay(10);
  Serial.println(top.get_press());
}*/